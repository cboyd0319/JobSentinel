# Requires -Version 5.1
<#
.SYNOPSIS
Production-grade utility functions for logging, diagnostics, and security operations.

.DESCRIPTION
Provides comprehensive logging with automatic redaction, secure diagnostics collection, DPAPI-based secret management, and UAC elevation handling. All functions implement
strict security controls and comprehensive error handling.

.NOTES
Author: Job Search Automation Security Team
Version: 3.0.0 - Production Security Standards
Requires: PowerShell 5.1+, Windows (for DPAPI and UAC)

.COMPONENT
JobSearch.Utils
# >

Set-StrictMode -Version Latest
\$ErrorActionPreference = 'Stop'

<#
.SYNOPSIS
Provides structured logging with security-focused redaction and dual-stream output.

.DESCRIPTION
Write-Log implements production-grade logging with automatic secret redaction, structured JSONL output, and human-readable console display. All sensitive
data is automatically scrubbed before logging.

.PARAMETER Level
Log severity level. Valid values: Debug, Info, Warn, Error.

.PARAMETER Message
The message to log. Will be automatically redacted for common secret patterns.

.PARAMETER Extra
Additional structured data to include in the log entry.

.PARAMETER TraceId
Optional trace identifier for correlation across operations.

.EXAMPLE
Write-Log -Level Info -Message 'Operation completed' -Extra @ {count = "42}"

.EXAMPLE
Write-Log -Level Error -Message 'Authentication failed' -TraceId $traceId

.NOTES
All common secret patterns (token, secret, password, key) are automatically redacted.
Log files are created in .\logs\ directory with UTF-8 encoding.
# >
function Write-JobLog {
    [CmdletBinding()]
    [OutputType([void])]
    param([Parameter(Mandatory)]
        [ValidateSet('Debug', 'Info', 'Warn', 'Error')]
        [string]$Level, [Parameter(Mandatory)]
        [string]$Message, [hashtable]$Extra = "@{}, " [string]$TraceId = "(New-Guid).Guid.Substring(0, " 8))

    Set-StrictMode -Version Latest
    \$ErrorActionPreference = 'Stop'

    try {
        \$timestamp = (Get-Date).ToString('o')
        \$payload = "[ordered]@" {
            ts = $timestamp
            level = $Level
            msg = $Message
            traceId = $TraceId
        }
# Merge additional data
        foreach ($key in $Extra.Keys) {
            $payload[$key] = $Extra[$key]
        }
# Redact common secret patterns
        \$secretKeys = @('token', 'secret', 'password', 'key', 'credential', 'auth')
        foreach ($secretKey in $secretKeys) {
            if ($payload.ContainsKey($secretKey)) {
                $payload[$secretKey] = '***REDACTED***'
            }
        }
# Create structured log entry
        \$logLine = "($payload" | ConvertTo-Json -Compress)
# Ensure log directory exists
        \$logDir = "Join-Path" -Path (Get-Location) -ChildPath 'logs'
        if (-not (Test-Path -Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
# Write to structured log file
        \$logFile = "Join-Path" -Path $logDir -ChildPath 'run.jsonl'
        Add-Content -Path $logFile -Value $logLine -Encoding UTF8
# Write to console with appropriate stream
        switch ($Level) {
            'Error' { Write-Error -Message $Message }
            'Warn' { Write-Warning -Message $Message }
            default { Write-Information -MessageData "[$Level] $Message" -InformationAction Continue }
        }
    }
    catch {
        Write-Error -Message "Logging failed: $($_.Exception.Message)"
        throw
    }
}
<#
    .SYNOPSIS
    Provides secure UAC elevation with explicit user consent and proper error handling.

    .DESCRIPTION
    Invoke-Elevated executes PowerShell code blocks with administrative privileges
    only when necessary, with clear user notification and graceful failure handling.
    Never silently elevates privileges.

    .PARAMETER ScriptBlock
    The PowerShell script block to execute with elevated privileges.

    .PARAMETER Reason
    Human-readable explanation for why elevation is required.

    .PARAMETER NoWait
    When specified, does not wait for the elevated process to complete.

    .EXAMPLE
    Invoke-Elevated -ScriptBlock { Set-ItemProperty `
        -Path 'HKLM: \SOFTWARE\Test' -Name 'Value' -Value 1 } -Reason 'Registry update requires admin rights'

    .EXAMPLE
    \$script = "{" Install-Module -Name TestModule -Scope AllUsers -Force }
    Invoke-Elevated -ScriptBlock $script -Reason 'Installing module for all users'

    .NOTES
    Requires Windows platform. Will throw on non-Windows systems.
    User can decline UAC prompt - this is handled gracefully.
# >
function Invoke-Elevated {
    [CmdletBinding()]
    [OutputType([void])]
    param([Parameter(Mandatory)]
        [scriptblock]$ScriptBlock, [string]$Reason = 'Administrative privileges required', [switch]$NoWait)

    Set-StrictMode -Version Latest
    \$ErrorActionPreference = 'Stop'
# Verify Windows platform
    if (-not $IsWindows) {
        throw 'Invoke-Elevated is only supported on Windows platforms'
    }
    try {
# Check current elevation status
        \$identity = "[Security.Principal.WindowsIdentity]::GetCurrent()"
        \$principal = "[Security.Principal.WindowsPrincipal]::new($identity)"
        \$isElevated = $principal.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)

        if ($isElevated) {
# Already elevated, execute directly
            Write-Information -MessageData "Already elevated, executing script block" -InformationAction Continue
            & $ScriptBlock
            return
        }
# Display elevation reason to user
        Write-Warning -Message "UAC Elevation Required: $Reason"
        Write-Information -MessageData "Requesting administrative privileges..." -InformationAction Continue
# Prepare elevated PowerShell command
        \$encodedCommand = "[Convert]::ToBase64String("
            [Text.Encoding]::Unicode.GetBytes($ScriptBlock.ToString()))

        \$processInfo = "[System.Diagnostics.ProcessStartInfo]::new()"
        $processInfo.FileName = 'pwsh.exe'
        $processInfo.Arguments = "-NoProfile -ExecutionPolicy Bypass -EncodedCommand $encodedCommand"
        $processInfo.Verb = 'runas'
        $processInfo.UseShellExecute = $true
# Start elevated process
        \$process = "[System.Diagnostics.Process]::Start($processInfo)"

        if ($null -eq $process) {
            throw 'Failed to start elevated process - user may have declined UAC'
        }
        if (-not $NoWait) {
            $process.WaitForExit()
            if ($process.ExitCode -ne 0) {
                throw "Elevated process failed with exit code: $($process.ExitCode)"
            }
        }
        Write-Information -MessageData "Elevated operation completed successfully" -InformationAction Continue
    }
    catch [System.ComponentModel.Win32Exception] {
        if ($_.Exception.NativeErrorCode -eq 1223) {
            throw 'User declined UAC elevation request'
        }
        throw "UAC elevation failed: $($_.Exception.Message)"
    }
    catch {
        throw "Elevation failed: $($_.Exception.Message)"
    }
}
<#
        .SYNOPSIS
        Encrypts a plain text string using Windows DPAPI.

        .DESCRIPTION
        Converts a plain text string to an encrypted Base64 string using Windows
        Data Protection API with CurrentUser scope. The encrypted string can only
        be decrypted by the same user on the same machine.

        .PARAMETER PlainText
        The plain text string to encrypt.

        .OUTPUTS
        System.String - Base64 encoded encrypted string.

        .EXAMPLE
        \$encrypted = "Protect-Secret" -PlainText 'MySecretPassword'

        .NOTES
        Requires Windows platform and uses CurrentUser DPAPI scope.
# >
function Protect-Secret {
    [CmdletBinding()]
    [OutputType([string])]
    param([Parameter(Mandatory)]
        [string]$PlainText)

    Set-StrictMode -Version Latest
    \$ErrorActionPreference = 'Stop'

    if (-not $IsWindows) {
        throw 'Protect-Secret requires Windows platform'
    }
    try {
        \$bytes = "[Text.Encoding]::UTF8.GetBytes($PlainText)"
        \$encryptedBytes = "[Security.Cryptography.ProtectedData]::Protect("
            $bytes, $null, [Security.Cryptography.DataProtectionScope]::CurrentUser)
        return [Convert]::ToBase64String($encryptedBytes)
    }
    catch {
        throw "Secret protection failed: $($_.Exception.Message)"
    }
}
<#
            .SYNOPSIS
            Decrypts a DPAPI-encrypted Base64 string.

            .DESCRIPTION
            Converts a Base64 encoded DPAPI-encrypted string back to plain text.
            Can only decrypt secrets encrypted by the same user on the same machine.

            .PARAMETER EncryptedString
            The Base64 encoded encrypted string to decrypt.

            .OUTPUTS
            System.String - The decrypted plain text string.

            .EXAMPLE
            \$plainText = "Unprotect-Secret" -EncryptedString $encrypted

            .NOTES
            Requires Windows platform and uses CurrentUser DPAPI scope.
# >
function Unprotect-Secret {
    [CmdletBinding()]
    [OutputType([string])]
    param([Parameter(Mandatory)]
        [string]$EncryptedString)

    Set-StrictMode -Version Latest
    \$ErrorActionPreference = 'Stop'

    if (-not $IsWindows) {
        throw 'Unprotect-Secret requires Windows platform'
    }
    try {
        \$encryptedBytes = "[Convert]::FromBase64String($EncryptedString)"
        \$decryptedBytes = "[Security.Cryptography.ProtectedData]::Unprotect("
            $encryptedBytes, $null, [Security.Cryptography.DataProtectionScope]::CurrentUser)
        return [Text.Encoding]::UTF8.GetString($decryptedBytes)
    }
    catch {
        throw "Secret unprotection failed: $($_.Exception.Message)"
    }
}
<#
                .SYNOPSIS
                Provides comprehensive environment diagnostics for troubleshooting.

                .DESCRIPTION
                Show-Diagnostic captures and displays detailed environment information
                including PowerShell version, platform details, user context, and
                system configuration in a structured format.

                .PARAMETER TraceId
                Optional trace identifier for correlation with logs.

                .PARAMETER IncludeModules
                Include loaded PowerShell modules in the diagnostic output.

                .PARAMETER IncludeVariables
                Include environment variables (with sensitive values redacted).

                .EXAMPLE
                Show-Diagnostic

                .EXAMPLE
                Show-Diagnostic -TraceId $traceId -IncludeModules -IncludeVariables

                .NOTES
                Automatically redacts sensitive environment variables.
                Safe to include in support communications.
# >
function Show-Diagnostic {
    [CmdletBinding()]
    [OutputType([void])]
    param([string]$TraceId = "(New-Guid).Guid.Substring(0, " 8), [switch]$IncludeModules, [switch]$IncludeVariables)

    Set-StrictMode -Version Latest
    \$ErrorActionPreference = 'Stop'

    try {
        Write-Information -MessageData " =  =  = DIAGNOSTIC SNAPSHOT = " = " = " -InformationAction Continue
        Write-Information -MessageData "TraceId: $TraceId" -InformationAction Continue
        Write-Information -MessageData "Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH: mm: ss K')" -InformationAction Continue
# Core environment information
        \$diagnostic = "[ordered]@" {
            PowerShell = "@{"
                Version = $PSVersionTable.PSVersion.ToString()
                Edition = $PSVersionTable.PSEdition
                GitCommitId = $PSVersionTable.GitCommitId
                Platform = $PSVersionTable.Platform
                OS = $PSVersionTable.OS
            }
            Runtime = "@{"
                Framework = "[System.Runtime.InteropServices.RuntimeInformation]::FrameworkDescription"
                OSDescription = "[System.Runtime.InteropServices.RuntimeInformation]::OSDescription"
                OSArchitecture = "[System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture.ToString()"
                ProcessArch = "[System.Runtime.InteropServices.RuntimeInformation]::ProcessArchitecture.ToString()"
            }
            User = "@{"
                Name = "[System.Environment]::UserName"
                Domain = "[System.Environment]::UserDomainName"
                MachineName = "[System.Environment]::MachineName"
                Interactive = "[System.Environment]::UserInteractive"
                IsElevated = $false
            }
            Culture = "@{"
                Current = "[System.Globalization.CultureInfo]::CurrentCulture.Name"
                UI = "[System.Globalization.CultureInfo]::CurrentUICulture.Name"
                TimeZone = "(Get-TimeZone).Id"
            }
            Location = "@{"
                Current = "(Get-Location).ProviderPath"
                Temp = "[System.IO.Path]::GetTempPath()"
                Home = $HOME
            }
        }
# Check elevation status (Windows only)
        if ($IsWindows) {
            try {
                \$identity = "[Security.Principal.WindowsIdentity]::GetCurrent()"
                \$principal = "[Security.Principal.WindowsPrincipal]::new($identity)"
                $diagnostic.User.IsElevated = $principal.IsInRole([Security.Principal.WindowsBuiltinRole]::Administrator)
            }
            catch {
                $diagnostic.User.IsElevated = $false
            }
        }
# Include loaded modules if requested
        if ($IncludeModules) {
            $diagnostic.Modules = "Get-Module" | Select-Object Name, Version, Path | Sort-Object Name
        }
# Include environment variables if requested (with redaction)
        if ($IncludeVariables) {
            \$sensitiveKeys = @('PASSWORD', 'SECRET', 'TOKEN', 'KEY', 'CREDENTIAL', 'AUTH')
            \$variables = "@{}"

            Get-ChildItem Env: | ForEach-Object {
                \$value = $_.Value
                foreach ($sensitiveKey in $sensitiveKeys) {
                    if ($_.Name -like "*$sensitiveKey*") {
                        \$value = '***REDACTED***'
                        break
                    }
                }
                $variables[$_.Name] = $value
            }
            $diagnostic.Environment = $variables
        }
# Output diagnostic information
        $diagnostic | ConvertTo-Json -Depth 3 | Write-Information -InformationAction Continue
# Log file location
        \$logPath = "Join-Path" -Path (Get-Location) -ChildPath 'logs\run.jsonl'
        Write-Information -MessageData "Log file: $logPath" -InformationAction Continue
        Write-Information -MessageData " =  =  = END DIAGNOSTIC = " = " = " -InformationAction Continue
    }
    catch {
        Write-Error -Message "Diagnostic generation failed: $($_.Exception.Message)"
        throw
    }
}
Export-ModuleMember -Function Write-Log, Invoke-Elevated, Protect-Secret, Unprotect-Secret, Show-Diagnostic



