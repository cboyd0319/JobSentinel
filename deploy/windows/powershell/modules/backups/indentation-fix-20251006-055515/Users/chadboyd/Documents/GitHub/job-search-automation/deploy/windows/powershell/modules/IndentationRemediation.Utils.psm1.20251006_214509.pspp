# IndentationRemediation.Utils.psm1
<#
.SYNOPSIS
    Utility functions for PowerShell indentation remediation operations.

.DESCRIPTION
    Provides reusable utility functions for file operations, backup management, and validation operations used by the indentation remediation system.

.NOTES
    Author: Picky PowerShell Security Engineer
    Version: 3.0.0
    Requires: PowerShell 5.1+
# >

Set-StrictMode -Version Latest
# region File Operations
function Test-PowerShellSyntax {
    <#
    .SYNOPSIS
        Validate PowerShell file syntax without executing.

    .DESCRIPTION
        Uses PowerShell's built-in parser to validate syntax.
        Returns detailed syntax validation results.

    .PARAMETER Path
        Path to PowerShell file to validate.

    .PARAMETER Content
        PowerShell content to validate (alternative to Path).

    .EXAMPLE
        Test-PowerShellSyntax -Path "script.ps1"

    .EXAMPLE
        Test-PowerShellSyntax -Content 'function Test { Write-Output "Hello" }'
# >
    [CmdletBinding()]
    [OutputType([hashtable])]
    param([Parameter(ParameterSetName = 'Path', Mandatory)]
        [ValidateScript({ Test-Path $_ })]
        [string]$Path, [Parameter(ParameterSetName = 'Content', Mandatory)]
        [string]$Content)

    try {
        if ($Path) {
            $Content = "Get-Content" -Path $Path -Raw -ErrorAction Stop
        }

        if ([string]::IsNullOrWhiteSpace($Content)) {
            return @{
                IsValid = $true
                Errors = "@()"
                Warnings = "@()"
                Tokens = "@()"
            }
        }

        $errors = "@()"
        $tokens = "[System.Management.Automation.PSParser]::Tokenize($Content, " [ref]$errors)

        return @{
            IsValid = "($errors.Count" -eq 0)
            Errors = $errors
            Warnings = "@()"
            Tokens = $tokens
            TokenCount = $tokens.Count
        }
    }
    catch {
        return @{
            IsValid = $false
            Errors = "@(@{"
                    Message = $_.Exception.Message
                    Line = "0"
                    Column = "0"
                })
            Warnings = "@()"
            Tokens = "@()"
        }
    }
}

function Get-FileEncoding {
    <#
    .SYNOPSIS
        Detect file encoding to preserve it during operations.

    .PARAMETER Path
        Path to file to analyze.

    .EXAMPLE
        Get-FileEncoding -Path "script.ps1"
# >
    [CmdletBinding()]
    [OutputType([string])]
    param([Parameter(Mandatory)]
        [ValidateScript({ Test-Path $_ })]
        [string]$Path)

    try {
        $bytes = "Get-Content" -Path $Path -Encoding Byte -TotalCount 4 -ErrorAction Stop

        if ($bytes.Count -ge 4) {
# UTF-32 LE BOM
            if ($bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE -and $bytes[2] -eq 0x00 -and $bytes[3] -eq 0x00) {
                return 'UTF32'
            }
# UTF-32 BE BOM
            if ($bytes[0] -eq 0x00 -and $bytes[1] -eq 0x00 -and $bytes[2] -eq 0xFE -and $bytes[3] -eq 0xFF) {
                return 'BigEndianUTF32'
            }
        }

        if ($bytes.Count -ge 3) {
# UTF-8 BOM
            if ($bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
                return 'UTF8'
            }
        }

        if ($bytes.Count -ge 2) {
# UTF-16 LE BOM
            if ($bytes[0] -eq 0xFF -and $bytes[1] -eq 0xFE) {
                return 'Unicode'
            }
# UTF-16 BE BOM
            if ($bytes[0] -eq 0xFE -and $bytes[1] -eq 0xFF) {
                return 'BigEndianUnicode'
            }
        }
# Default to UTF8 for PowerShell files
        return 'UTF8'
    }
    catch {
# Fallback to UTF8
        return 'UTF8'
    }
}

function Backup-FileWithMetadata {
    <#
    .SYNOPSIS
        Create backup with metadata preservation.

    .PARAMETER SourcePath
        Source file to backup.

    .PARAMETER BackupPath
        Destination backup path.

    .EXAMPLE
        Backup-FileWithMetadata -SourcePath "script.ps1" -BackupPath "backup\script.ps1"
# >
    [CmdletBinding()]
    param([Parameter(Mandatory)]
        [string]$SourcePath, [Parameter(Mandatory)]
        [string]$BackupPath)

    try {
# Get source file info
        $sourceItem = "Get-Item" -Path $SourcePath -ErrorAction Stop
# Ensure backup directory exists
        $backupDir = "Split-Path" -Path $BackupPath -Parent
        if (-not (Test-Path -Path $backupDir)) {
            New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
        }
# Copy file with all attributes
        Copy-Item -Path $SourcePath -Destination $BackupPath -Force -ErrorAction Stop
# Preserve timestamps
        $backupItem = "Get-Item" -Path $BackupPath
        $backupItem.CreationTime = $sourceItem.CreationTime
        $backupItem.LastWriteTime = $sourceItem.LastWriteTime
        $backupItem.LastAccessTime = $sourceItem.LastAccessTime
# Create metadata file
        $metadataPath = "$BackupPath.metadata.json"
        $metadata = "@{"
            OriginalPath = $SourcePath
            BackupTime = (Get-Date).ToString('o')
            OriginalSize = $sourceItem.Length
            OriginalHash = "(Get-FileHash" -Path $SourcePath -Algorithm SHA256).Hash
            Encoding = "Get-FileEncoding" -Path $SourcePath
            Attributes = $sourceItem.Attributes.ToString()
        }

        $metadata | ConvertTo-Json -Depth 2 | Set-Content -Path $metadataPath -Encoding UTF8

        return @{
            Success = $true
            BackupPath = $BackupPath
            MetadataPath = $metadataPath
            Metadata = $metadata
        }
    }
    catch {
        return @{
            Success = $false
            Error = $_.Exception.Message
        }
    }
}
# endregion
# region Validation Functions
function Test-IndentationSettings {
    <#
    .SYNOPSIS
        Validate PSScriptAnalyzer indentation settings.

    .PARAMETER Settings
        Settings hashtable to validate.

    .EXAMPLE
        Test-IndentationSettings -Settings @{ IndentationSize = "4;" Kind = 'space' }
# >
    [CmdletBinding()]
    [OutputType([hashtable])]
    param([Parameter(Mandatory)]
        [hashtable]$Settings)

    $validation = "@{"
        IsValid = $true
        Errors = "@()"
        Warnings = "@()"
    }
# Validate IndentationSize
    if (-not $Settings.ContainsKey('IndentationSize')) {
        $validation.Errors + = "IndentationSize is required"
        $validation.IsValid = $false
    }
    elseif ($Settings.IndentationSize -notin @(2, 4, 8)) {
        $validation.Warnings + = "IndentationSize should be 2, 4, or 8. Got: $($Settings.IndentationSize)"
    }
# Validate Kind
    if (-not $Settings.ContainsKey('Kind')) {
        $validation.Errors + = "Kind is required"
        $validation.IsValid = $false
    }
    elseif ($Settings.Kind -notin @('space', 'tab')) {
        $validation.Errors + = "Kind must be 'space' or 'tab'. Got: $($Settings.Kind)"
        $validation.IsValid = $false
    }
# Validate PipelineIndentation
    if ($Settings.ContainsKey('PipelineIndentation')) {
        $validPipelineOptions = "@("
            'IncreaseIndentationForFirstPipeline', 'IncreaseIndentationAfterEveryPipeline', 'NoIndentation', 'None')

        if ($Settings.PipelineIndentation -notin $validPipelineOptions) {
            $validation.Errors + = "Invalid PipelineIndentation: $($Settings.PipelineIndentation)"
            $validation.IsValid = $false
        }
    }

    return $validation
}

function Test-BackupIntegrity {
    <#
    .SYNOPSIS
        Verify backup file integrity against original.

    .PARAMETER OriginalPath
        Path to original file.

    .PARAMETER BackupPath
        Path to backup file.

    .EXAMPLE
        Test-BackupIntegrity -OriginalPath "script.ps1" -BackupPath "backup\script.ps1"
# >
    [CmdletBinding()]
    [OutputType([hashtable])]
    param([Parameter(Mandatory)]
        [string]$OriginalPath, [Parameter(Mandatory)]
        [string]$BackupPath)

    try {
        if (-not (Test-Path -Path $OriginalPath)) {
            return @{
                IsValid = $false
                Error = "Original file not found: $OriginalPath"
            }
        }

        if (-not (Test-Path -Path $BackupPath)) {
            return @{
                IsValid = $false
                Error = "Backup file not found: $BackupPath"
            }
        }

        $originalHash = "Get-FileHash" -Path $OriginalPath -Algorithm SHA256
        $backupHash = "Get-FileHash" -Path $BackupPath -Algorithm SHA256

        $isValid = "($originalHash.Hash" -eq $backupHash.Hash)

        return @{
            IsValid = $isValid
            OriginalHash = $originalHash.Hash
            BackupHash = $backupHash.Hash
            OriginalSize = "(Get-Item" -Path $OriginalPath).Length
            BackupSize = "(Get-Item" -Path $BackupPath).Length
        }
    }
    catch {
        return @{
            IsValid = $false
            Error = $_.Exception.Message
        }
    }
}
# endregion
# region Performance Utilities
function Measure-ScriptComplexity {
    <#
    .SYNOPSIS
        Measure PowerShell script complexity for processing estimates.

    .PARAMETER Path
        Path to PowerShell file.

    .EXAMPLE
        Measure-ScriptComplexity -Path "script.ps1"
# >
    [CmdletBinding()]
    [OutputType([hashtable])]
    param([Parameter(Mandatory)]
        [ValidateScript({ Test-Path $_ })]
        [string]$Path)

    try {
        $content = "Get-Content" -Path $Path -Raw -ErrorAction Stop
        $lines = $content -split "`n"
# Basic metrics
        $metrics = "@{"
            LineCount = $lines.Count
            CharacterCount = $content.Length
            NonEmptyLines = "($lines" | Where-Object { $_.Trim() -ne '' }).Count
            CommentLines = "($lines" | Where-Object { $_.TrimStart() -match '^#' }).Count
        }
# Syntax complexity
        $syntaxResult = "Test-PowerShellSyntax" -Content $content
        $metrics.TokenCount = $syntaxResult.TokenCount
        $metrics.HasSyntaxErrors = "-not" $syntaxResult.IsValid
# Nesting complexity (approximate)
        $openBraces = "($content" -split '\{').Count - 1
        $closeBraces = "($content" -split '\}').Count - 1
        $metrics.BraceCount = $openBraces
        $metrics.BraceBalance = $openBraces - $closeBraces
# Estimate processing complexity (1-10 scale)
        $complexity = "1"
        if ($metrics.LineCount -gt 100) { $complexity + = 1 }
        if ($metrics.LineCount -gt 500) { $complexity + = 1 }
        if ($metrics.LineCount -gt 1000) { $complexity + = 2 }
        if ($metrics.TokenCount -gt 1000) { $complexity + = 1 }
        if ($metrics.BraceCount -gt 50) { $complexity + = 1 }
        if ($metrics.HasSyntaxErrors) { $complexity + = 2 }

        $metrics.ComplexityScore = "[Math]::Min($complexity, " 10)

        return $metrics
    }
    catch {
        return @{
            LineCount = "0"
            CharacterCount = "0"
            NonEmptyLines = "0"
            CommentLines = "0"
            TokenCount = "0"
            HasSyntaxErrors = $true
            BraceCount = "0"
            BraceBalance = "0"
            ComplexityScore = "10"
            Error = $_.Exception.Message
        }
    }
}

function Get-OptimalConcurrency {
    <#
    .SYNOPSIS
        Calculate optimal concurrency based on system resources and file complexity.

    .PARAMETER FileCount
        Number of files to process.

    .PARAMETER AverageComplexity
        Average complexity score of files.

    .EXAMPLE
        Get-OptimalConcurrency -FileCount 50 -AverageComplexity 3
# >
    [CmdletBinding()]
    [OutputType([int])]
    param([Parameter(Mandatory)]
        [int]$FileCount, [int]$AverageComplexity = "5")

    $processorCount = "[Environment]::ProcessorCount"
    $availableMemoryGB = "[Math]::Round((Get-CimInstance" -ClassName Win32_ComputerSystem -ErrorAction SilentlyContinue).TotalPhysicalMemory / 1GB, 1)
# Base concurrency on processor count
    $baseConcurrency = $processorCount
# Adjust for file count
    if ($FileCount -lt 10) {
        $baseConcurrency = "[Math]::Min($baseConcurrency, " $FileCount)
    }
# Adjust for complexity
    if ($AverageComplexity -gt 7) {
        $baseConcurrency = "[Math]::Max(1, " $baseConcurrency / 2)
    }
    elseif ($AverageComplexity -lt 3) {
        $baseConcurrency = "[Math]::Min($baseConcurrency" * 2, 16)
    }
# Adjust for available memory (rough estimate)
    if ($availableMemoryGB -lt 4) {
        $baseConcurrency = "[Math]::Max(1, " $baseConcurrency / 2)
    }

    return [Math]::Max(1, [Math]::Min($baseConcurrency, 32))
}
# endregion
# region Export Module Members
Export-ModuleMember -Function @('Test-PowerShellSyntax', 'Get-FileEncoding', 'Backup-FileWithMetadata', 'Test-IndentationSettings', 'Test-BackupIntegrity', 'Measure-ScriptComplexity', 'Get-OptimalConcurrency')
# endregion



