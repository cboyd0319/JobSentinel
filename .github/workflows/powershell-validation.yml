# PowerShell Script Validation
# Validates PowerShell scripts using PSScriptAnalyzer and custom tests

name: ü™ü PowerShell Validation

on:
  push:
    paths:
      - '**/*.ps1'
      - '.github/workflows/powershell-validation.yml'
  pull_request:
    paths:
      - '**/*.ps1'
  workflow_dispatch:

jobs:
  powershell-analysis:
    name: üìù PowerShell Script Analysis
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install PSScriptAnalyzer
        shell: pwsh
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser

      - name: Run PSScriptAnalyzer
        shell: pwsh
        run: |
          Write-Host "üîç Running PowerShell Script Analysis..."

          # Get all PowerShell files
          $psFiles = Get-ChildItem -Path . -Filter "*.ps1" -Recurse

          $issues = @()

          foreach ($file in $psFiles) {
              Write-Host "Analyzing: $($file.FullName)"

              $results = Invoke-ScriptAnalyzer -Path $file.FullName -Severity @('Error','Warning') -Recurse

              if ($results) {
                  $issues += $results
                  Write-Host "‚ö†Ô∏è  Found $($results.Count) issues in $($file.Name)" -ForegroundColor Yellow

                  foreach ($result in $results) {
                      Write-Host "  $($result.Severity): $($result.Message)" `
                          -ForegroundColor ($result.Severity -eq 'Error' ? 'Red' : 'Yellow')
                      Write-Host "    Line $($result.Line): $($result.ScriptName)" -ForegroundColor Gray
                  }
              } else {
                  Write-Host "‚úÖ No issues found in $($file.Name)" -ForegroundColor Green
              }
          }

          # Summary
          Write-Host ""
          Write-Host "üìä Analysis Summary:" -ForegroundColor Cyan
          Write-Host "Files analyzed: $($psFiles.Count)"
          Write-Host "Total issues: $($issues.Count)"

          $errors = $issues | Where-Object { $_.Severity -eq 'Error' }
          $warnings = $issues | Where-Object { $_.Severity -eq 'Warning' }

          Write-Host "Errors: $($errors.Count)" -ForegroundColor Red
          Write-Host "Warnings: $($warnings.Count)" -ForegroundColor Yellow

          # Fail if there are errors
          if ($errors.Count -gt 0) {
              Write-Host "‚ùå PowerShell analysis failed due to errors" -ForegroundColor Red
              exit 1
          } else {
              Write-Host "‚úÖ PowerShell analysis passed" -ForegroundColor Green
          }

  powershell-syntax-test:
    name: üß™ PowerShell Syntax Test
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Test PowerShell Syntax
        shell: pwsh
        run: |
          Write-Host "üß™ Testing PowerShell Syntax..."

          $psFiles = Get-ChildItem -Path . -Filter "*.ps1" -Recurse
          $syntaxErrors = @()

          foreach ($file in $psFiles) {
              Write-Host "Testing syntax: $($file.Name)"

              try {
                  # Parse the script to check for syntax errors
                  $tokens = $null
                  $parseErrors = $null
                  $ast = [System.Management.Automation.Language.Parser]::ParseFile(
                      $file.FullName, [ref]$tokens, [ref]$parseErrors
                  )

                  if ($parseErrors) {
                      $syntaxErrors += $parseErrors
                      Write-Host "‚ùå Syntax errors in $($file.Name):" -ForegroundColor Red
                      foreach ($error in $parseErrors) {
                          Write-Host "  Line $($error.Extent.StartLineNumber): $($error.Message)" -ForegroundColor Red
                      }
                  } else {
                      Write-Host "‚úÖ Syntax OK: $($file.Name)" -ForegroundColor Green
                  }
              } catch {
                  Write-Host "‚ùå Failed to parse $($file.Name): $($_.Exception.Message)" -ForegroundColor Red
                  $syntaxErrors += $_
              }
          }

          Write-Host ""
          Write-Host "üìä Syntax Test Summary:" -ForegroundColor Cyan
          Write-Host "Files tested: $($psFiles.Count)"
          Write-Host "Syntax errors: $($syntaxErrors.Count)"

          if ($syntaxErrors.Count -gt 0) {
              Write-Host "‚ùå Syntax test failed" -ForegroundColor Red
              exit 1
          } else {
              Write-Host "‚úÖ All PowerShell files have valid syntax" -ForegroundColor Green
          }

  powershell-security-test:
    name: üîí PowerShell Security Test
    runs-on: windows-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: PowerShell Security Analysis
        shell: pwsh
        run: |
          Write-Host "üîí Running PowerShell Security Analysis..."

          $psFiles = Get-ChildItem -Path . -Filter "*.ps1" -Recurse
          $securityIssues = @()

          # Define security patterns to check
          $securityPatterns = @{
              'Invoke-Expression with user input' = 'Invoke-Expression.*\$.*'
              'Unrestricted execution policy' = 'Set-ExecutionPolicy.*Unrestricted'
              'Download without verification' = 'DownloadString.*http[^s]'
              'Hardcoded credentials' = '(password|secret|key)\s*=\s*["\'][^"\']{8,}["\']'
              'Unsafe web requests' = 'System\.Net\.WebClient.*Download'
          }

          foreach ($file in $psFiles) {
              Write-Host "Security scan: $($file.Name)"
              $content = Get-Content -Path $file.FullName -Raw

              foreach ($patternName in $securityPatterns.Keys) {
                  if ($content -match $securityPatterns[$patternName]) {
                      $securityIssues += @{
                          File = $file.Name
                          Issue = $patternName
                          Pattern = $securityPatterns[$patternName]
                      }
                      Write-Host "‚ö†Ô∏è  Security concern in $($file.Name): $patternName" -ForegroundColor Yellow
                  }
              }
          }

          Write-Host ""
          Write-Host "üìä Security Analysis Summary:" -ForegroundColor Cyan
          Write-Host "Files scanned: $($psFiles.Count)"
          Write-Host "Security concerns: $($securityIssues.Count)"

          if ($securityIssues.Count -gt 0) {
              Write-Host "‚ö†Ô∏è  Security analysis completed with concerns" -ForegroundColor Yellow
              Write-Host "Review the issues above - they may be acceptable in your context"
          } else {
              Write-Host "‚úÖ No security concerns found" -ForegroundColor Green
          }

  cross-platform-test:
    name: üåê Cross-Platform PowerShell Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install PowerShell (non-Windows)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "ubuntu-latest" ]]; then
            sudo apt-get update
            sudo apt-get install -y wget apt-transport-https software-properties-common
            wget -q https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb
            sudo dpkg -i packages-microsoft-prod.deb
            sudo apt-get update
            sudo apt-get install -y powershell
          elif [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            brew install --cask powershell
          fi

      - name: Test PowerShell Compatibility
        shell: pwsh
        run: |
          Write-Host "üåê Testing PowerShell compatibility on ${{ matrix.os }}"

          # Test basic PowerShell features used in our scripts
          try {
              # Test common cmdlets
              Get-Location | Out-Null
              Test-Path "." | Out-Null

              # Test .NET Framework features
              [System.Environment]::GetEnvironmentVariable("PATH") | Out-Null

              # Test file operations
              $testFile = "test-$(Get-Random).txt"
              "test" | Out-File -FilePath $testFile
              if (Test-Path $testFile) {
                  Remove-Item $testFile
                  Write-Host "‚úÖ File operations work correctly"
              }

              Write-Host "‚úÖ PowerShell compatibility test passed on ${{ matrix.os }}"

          } catch {
              Write-Host "‚ùå PowerShell compatibility issue on ${{ matrix.os }}: " `
                  "$($_.Exception.Message)" -ForegroundColor Red
              exit 1
          }
