# PowerShell Script Validation
# Validates PowerShell scripts using PSScriptAnalyzer and custom tests
name: PowerShell Validation
"on":
  push:
    paths:
      - '**/*.ps1'
      - '.github/workflows/powershell-validation.yml'
  pull_request:
    paths:
      - '**/*.ps1'
  workflow_dispatch:
jobs:
  powershell-analysis:
    name: PowerShell Script Analysis
    runs-on: windows-latest
    outputs:
      ps_files: ${{ steps.get_ps_files.outputs.ps_files }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Get PowerShell Files
        id: get_ps_files
        shell: pwsh
        run: |
          $psFiles = Get-ChildItem -Path . -Filter "*.ps1" -Recurse | Select-Object -ExpandProperty FullName
          $jsonOutput = (@($psFiles) | ConvertTo-Json)
          echo "ps_files<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8
          echo $jsonOutput | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          echo "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
      - name: Install PSScriptAnalyzer
        shell: pwsh
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
      - name: Run PSScriptAnalyzer
        shell: pwsh
        run: |
          Write-Host "Running PowerShell Script Analysis..."
          $psFiles = ConvertFrom-Json '${{ steps.get_ps_files.outputs.ps_files }}'
          $issues = @()
          foreach ($file in $psFiles) {
              Write-Host "Analyzing: $($file)"
              $results = Invoke-ScriptAnalyzer -Path $file -Severity @('Error','Warning')
              if ($results) {
                  $issues += $results
                  Write-Host "Found $($results.Count) issues in $(Split-Path -Leaf $file)" -ForegroundColor Yellow
                  foreach ($result in $results) {
                      Write-Host "  $($result.Severity): $($result.Message)" `
                          -ForegroundColor ($result.Severity -eq 'Error' ? 'Red' : 'Yellow')
                      Write-Host "    Line $($result.Line): $($result.ScriptName)" -ForegroundColor Gray
                  }
              } else {
                  Write-Host "No issues found in $(Split-Path -Leaf $file)" -ForegroundColor Green
              }
          }
          # Summary
          Write-Host ""
          Write-Host "Analysis Summary:" -ForegroundColor Cyan
          Write-Host "Files analyzed: $($psFiles.Count)"
          Write-Host "Total issues: $($issues.Count)"
          $errors = $issues | Where-Object { $_.Severity -eq 'Error' }
          $warnings = $issues | Where-Object { $_.Severity -eq 'Warning' }
          Write-Host "Errors: $($errors.Count)" -ForegroundColor Red
          Write-Host "Warnings: $($warnings.Count)" -ForegroundColor Yellow
          # Fail if there are errors
          if ($errors.Count -gt 0) {
              Write-Host "PowerShell analysis failed due to errors" -ForegroundColor Red
              exit 1
          } else {
              Write-Host "PowerShell analysis passed" -ForegroundColor Green
          }
  powershell-syntax-test:
    name: PowerShell Syntax Test
    runs-on: windows-latest
    needs: powershell-analysis
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: Test PowerShell Syntax
        shell: pwsh
        run: |
          Write-Host "Testing PowerShell Syntax..."
          $psFiles = ConvertFrom-Json '${{ needs.powershell-analysis.outputs.ps_files }}'
          $syntaxErrors = @()
          foreach ($file in $psFiles) {
              Write-Host "Testing syntax: $(Split-Path -Leaf $file)"
              try {
                  # Parse the script to check for syntax errors
                  $tokens = $null
                  $parseErrors = $null
                  $ast = [System.Management.Automation.Language.Parser]::ParseFile(
                      $file, [ref]$tokens, [ref]$parseErrors
                  )
                  if ($parseErrors) {
                      $syntaxErrors += $parseErrors
                      Write-Host "Syntax errors in $(Split-Path -Leaf $file):" -ForegroundColor Red
                      foreach ($error in $parseErrors) {
                          Write-Host "  Line $($error.Extent.StartLineNumber): $($error.Message)" -ForegroundColor Red
                      }
                  } else {
                      Write-Host "Syntax OK: $(Split-Path -Leaf $file)" -ForegroundColor Green
                  }
              } catch {
                  Write-Host "Failed to parse $($file): $($_.Exception.Message)" -ForegroundColor Red
                  $syntaxErrors += $_.Exception.Message
              }
          }
          Write-Host ""
          Write-Host "Syntax Test Summary:" -ForegroundColor Cyan
          Write-Host "Files tested: $($psFiles.Count)"
          Write-Host "Syntax errors: $($syntaxErrors.Count)"
          if ($syntaxErrors.Count -gt 0) {
              Write-Host "Syntax test failed" -ForegroundColor Red
              exit 1
          } else {
              Write-Host "All PowerShell files have valid syntax" -ForegroundColor Green
          }
  powershell-security-test:
    name: PowerShell Security Test
    runs-on: windows-latest
    needs: powershell-analysis
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
      - name: PowerShell Security Analysis
        shell: pwsh
        run: |
          Write-Host "Running PowerShell Security Analysis..."
          $psFiles = ConvertFrom-Json '${{ needs.powershell-analysis.outputs.ps_files }}'
          $securityIssues = @()
          # Define security patterns to check
          $securityPatterns = @{
              'Invoke-Expression with user input' = 'Invoke-Expression.*\$.*'
              'Unrestricted execution policy' = 'Set-ExecutionPolicy.*Unrestricted'
              'Download without verification' = 'DownloadString.*http[^s]'
              'Hardcoded credentials' = "(password|secret|key)\s*=\s*[`"'][^`"']{8,}[`"']"
              'Unsafe web requests' = 'System\.Net\.WebClient.*Download'
          }
          foreach ($file in $psFiles) {
              Write-Host "Security scan: $(Split-Path -Leaf $file)"
              $content = Get-Content -Path $file -Raw
              foreach ($patternName in $securityPatterns.Keys) {
                  if ($content -match $securityPatterns[$patternName]) {
                      $securityIssues += @{
                          File = $file
                          Issue = $patternName
                          Pattern = $securityPatterns[$patternName]
                      }
                      Write-Host "Security concern in $(Split-Path -Leaf $file): $patternName" -ForegroundColor Yellow
                  }
              }
          }
          Write-Host ""
          Write-Host "Security Analysis Summary:" -ForegroundColor Cyan
          Write-Host "Files scanned: $($psFiles.Count)"
          Write-Host "Security concerns: $($securityIssues.Count)"
          if ($securityIssues.Count -gt 0) {
              Write-Host "Security analysis completed with concerns" -ForegroundColor Yellow
              Write-Host "Review the issues above - they may be acceptable in your context"
          } else {
              Write-Host "No security concerns found" -ForegroundColor Green
          }
