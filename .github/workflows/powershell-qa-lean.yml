name: ğŸ’¸ PowerShell QA (Cost-Optimized)

# ğŸ’° COST-OPTIMIZED: Only runs when PowerShell files change
on:
  push:
    paths:
      - '**/*.ps1'
      - '**/*.psm1' 
      - '**/*.psd1'
      - 'qa/**'
      - '.github/workflows/powershell-qa-lean.yml'
    branches: [main, develop]
  
  pull_request:
    paths:
      - '**/*.ps1'
      - '**/*.psm1'
      - '**/*.psd1' 
      - 'qa/**'
      - '.github/workflows/powershell-qa-lean.yml'
    types: [opened, synchronize, reopened]
  
  workflow_dispatch:
    inputs:
      full_scan:
        description: 'Run full scan (ignores path filters)'
        required: false
        default: false
        type: boolean
      
      auto_fix:
        description: 'Apply automatic fixes'
        required: false
        default: false
        type: boolean

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  # ğŸ’° SINGLE JOB: Combines health check + analysis for cost efficiency
  powershell-qa:
    name: ğŸ” PowerShell Quality Check
    runs-on: ubuntu-latest  # ğŸ’° Cheapest runner
    timeout-minutes: 8      # ğŸ’° Short timeout to prevent runaway costs
    
    # ğŸ’° Skip if no PowerShell files changed (unless manual full scan)
    if: |
      github.event.inputs.full_scan == 'true' || 
      contains(join(github.event.commits.*.modified, ' '), '.ps1') ||
      contains(join(github.event.commits.*.modified, ' '), '.psm1') ||
      contains(join(github.event.commits.*.modified, ' '), '.psd1') ||
      contains(join(github.event.commits.*.added, ' '), '.ps1') ||
      contains(join(github.event.commits.*.added, ' '), '.psm1') ||
      contains(join(github.event.commits.*.added, ' '), '.psd1') ||
      github.event_name == 'pull_request' ||
      github.event_name == 'workflow_dispatch'
    
    outputs:
      issues-found: ${{ steps.analysis.outputs.issues }}
      files-scanned: ${{ steps.analysis.outputs.files }}
      needs-attention: ${{ steps.analysis.outputs.needs-attention }}
    
    steps:
      - name: ğŸ“¥ Checkout (Shallow)
        uses: actions/checkout@v5
        with:
          fetch-depth: 1  # ğŸ’° Shallow clone for speed
      
      - name: ğŸ”§ Setup PowerShell (Cached)
        shell: pwsh
        run: |
          # ğŸ’° Use system PowerShell where possible, only install what's needed
          if (-not (Get-Module -ListAvailable -Name PSScriptAnalyzer)) {
            Write-Output "ğŸ“¦ Installing PSScriptAnalyzer..."
            Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser -Repository PSGallery
          } else {
            Write-Output "âœ… PSScriptAnalyzer already available"
          }

      - name: ğŸ¥ Quick Health Check
        shell: pwsh
        run: |
          Write-Output "ğŸ¥ Quick health check..."
          
          # Check if QA system exists
          if (-not (Test-Path "psqa.ps1")) {
            Write-Output "âŒ QA system not found - using direct analysis"
            exit 0
          }
          
          # Quick validation
          try {
            & "./psqa.ps1" -Mode validate -Path "qa" -Timeout 30
            Write-Output "âœ… QA system healthy"
          } catch {
            Write-Output "âš ï¸ QA system issue, falling back to direct analysis: $_"
          }

      - name: ğŸ¯ Smart PowerShell Analysis
        id: analysis
        shell: pwsh
        run: |
          Write-Output "ğŸ¯ Running cost-optimized PowerShell analysis..."
          
          # ğŸ’° Find only changed PowerShell files if not full scan
          if ("${{ github.event.inputs.full_scan }}" -eq "true") {
            Write-Output "ğŸ” Full scan requested"
            $filesToScan = Get-ChildItem -Recurse -Include "*.ps1","*.psm1","*.psd1" | 
              Where-Object { $_.FullName -notlike "*/.venv/*" -and $_.FullName -notlike "*/node_modules/*" }
          } else {
            Write-Output "ğŸ¯ Scanning changed files only"
            
            # Get changed files from git (cost-optimized approach)
            $changedFiles = @()
            try {
              $gitFiles = git diff --name-only HEAD~1 HEAD 2>/dev/null | Where-Object { $_ -match '\.(ps1|psm1|psd1)$' }
              foreach ($file in $gitFiles) {
                if (Test-Path $file) {
                  $changedFiles += Get-Item $file
                }
              }
            } catch {
              # Fallback: scan all if git fails
              Write-Output "âš ï¸ Git diff failed, scanning all files"
              $changedFiles = Get-ChildItem -Recurse -Include "*.ps1","*.psm1","*.psd1" | 
                Where-Object { $_.FullName -notlike "*/.venv/*" }
            }
            
            $filesToScan = $changedFiles
          }
          
          $fileCount = ($filesToScan | Measure-Object).Count
          Write-Output "ğŸ“ Found $fileCount PowerShell files to scan"
          
          if ($fileCount -eq 0) {
            Write-Output "âœ… No PowerShell files to scan"
            Write-Output "issues=0" >> $env:GITHUB_OUTPUT
            Write-Output "files=0" >> $env:GITHUB_OUTPUT
            Write-Output "needs-attention=false" >> $env:GITHUB_OUTPUT
            exit 0
          }
          
          # ğŸ’° Use QA system if available, otherwise direct analysis
          $issues = @()
          $useQASystem = Test-Path "psqa.ps1"
          
          if ($useQASystem) {
            try {
              Write-Output "ğŸ”§ Using QA system for analysis..."
              $result = & "./psqa.ps1" -Mode analyze -Path ($filesToScan[0].Directory.FullName) 2>&1
              Write-Output $result
              
              # Count issues from QA system output
              $issueLines = $result | Where-Object { $_ -match "Issues found|violations|errors" }
              $issueCount = 0
              if ($issueLines) {
                $numbers = $issueLines | ForEach-Object { [regex]::Matches($_, '\d+').Value }
                $issueCount = ($numbers | Measure-Object -Sum).Sum
              }
            } catch {
              Write-Output "âš ï¸ QA system failed: $_"
              $useQASystem = $false
            }
          }
          
          if (-not $useQASystem) {
            Write-Output "ğŸ” Using direct PSScriptAnalyzer..."
            $issues = $filesToScan | ForEach-Object {
              Write-Output "  Analyzing: $($_.Name)"
              if (Test-Path "qa/config/PSScriptAnalyzerSettings.psd1") {
                Invoke-ScriptAnalyzer -Path $_.FullName -Settings "qa/config/PSScriptAnalyzerSettings.psd1" -ErrorAction SilentlyContinue
              } else {
                Invoke-ScriptAnalyzer -Path $_.FullName -ErrorAction SilentlyContinue
              }
            }
            $issueCount = ($issues | Measure-Object).Count
          }
          
          Write-Output "ğŸ“Š Analysis Results:"
          Write-Output "  Files Scanned: $fileCount"
          Write-Output "  Issues Found: $issueCount"
          
          # ğŸ’° Only create detailed reports if issues found
          if ($issueCount -gt 0) {
            Write-Output "ğŸ“‹ Issue Summary:"
            if ($issues) {
              $issues | Group-Object RuleName | Sort-Object Count -Descending | Select-Object -First 5 | ForEach-Object {
                Write-Output "  â€¢ $($_.Name): $($_.Count) occurrences"
              }
            }
          }
          
          # Set outputs
          Write-Output "issues=$issueCount" >> $env:GITHUB_OUTPUT
          Write-Output "files=$fileCount" >> $env:GITHUB_OUTPUT
          Write-Output "needs-attention=$(if ($issueCount -gt 0) { 'true' } else { 'false' })" >> $env:GITHUB_OUTPUT

      - name: ğŸ› ï¸ Auto-Fix (Optional)
        if: |
          steps.analysis.outputs.needs-attention == 'true' && 
          github.event.inputs.auto_fix == 'true' &&
          github.event_name == 'workflow_dispatch'
        shell: pwsh
        run: |
          Write-Output "ğŸ› ï¸ Applying automatic fixes..."
          
          if (Test-Path "psqa.ps1") {
            try {
              & "./psqa.ps1" -Mode fix -Path "."
              Write-Output "âœ… Auto-fixes applied successfully"
            } catch {
              Write-Output "âŒ Auto-fix failed: $_"
            }
          } else {
            Write-Output "âš ï¸ No QA system available for auto-fixing"
          }

      - name: ğŸ“Š Cost Summary
        if: always()
        run: |
          echo "## ğŸ’¸ Cost-Optimized PowerShell QA Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“Š Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Files Scanned**: ${{ steps.analysis.outputs.files }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Issues Found**: ${{ steps.analysis.outputs.issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner**: ubuntu-latest (cheapest)" >> $GITHUB_STEP_SUMMARY
          echo "- **Duration**: ~$(date -u +'%M:%S') minutes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.analysis.outputs.needs-attention }}" == "true" ]]; then
            echo "### âš ï¸ Action Required" >> $GITHUB_STEP_SUMMARY
            echo "PowerShell quality issues detected. Consider running:" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo './psqa.ps1 -Mode fix -Path .' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "### âœ… All Clear" >> $GITHUB_STEP_SUMMARY
            echo "No PowerShell quality issues detected! ğŸ‰" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ’° Cost Optimizations Applied" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Path filters (only runs when PS files change)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Ubuntu runner (cheapest available)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Shallow git clone" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Smart file detection" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Short timeout (8 minutes max)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Minimal artifact storage" >> $GITHUB_STEP_SUMMARY

  # ğŸ’° OPTIONAL: Manual fix job (only if requested)
  create-fix-pr:
    name: ğŸ”§ Create Auto-Fix PR
    runs-on: ubuntu-latest
    needs: powershell-qa
    if: |
      needs.powershell-qa.outputs.needs-attention == 'true' &&
      github.event.inputs.auto_fix == 'true' &&
      github.event_name == 'workflow_dispatch'
    timeout-minutes: 5
    
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: ğŸ”§ Setup PowerShell
        shell: pwsh
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser

      - name: ğŸ› ï¸ Apply Fixes
        shell: pwsh
        run: |
          if (Test-Path "psqa.ps1") {
            & "./psqa.ps1" -Mode fix -Path "."
          }

      - name: ğŸ“¤ Create PR
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "ğŸ¤– PowerShell: Auto-fix quality issues"
          title: "ğŸ¤– Auto-fix PowerShell Quality Issues"
          body: |
            ## ğŸ¤– Automated PowerShell Fixes
            
            This PR contains automatic fixes for PowerShell quality issues.
            
            **Files affected**: ${{ needs.powershell-qa.outputs.files }}
            **Issues fixed**: ${{ needs.powershell-qa.outputs.issues }}
            
            All fixes are safe and maintain existing functionality.
          branch: auto-fix/powershell-${{ github.run_number }}
          labels: automated, powershell, quality
          delete-branch: true