name: 💸 PowerShell QA (Cost-Optimized)

# 💰 COST-OPTIMIZED: Only runs when PowerShell files change
on:
  push:
    paths:
      - '**/*.ps1'
      - '**/*.psm1' 
      - '**/*.psd1'
      - 'qa/**'
      - '.github/workflows/powershell-qa-lean.yml'
    branches: [main, develop]
  
  pull_request:
    paths:
      - '**/*.ps1'
      - '**/*.psm1'
      - '**/*.psd1' 
      - 'qa/**'
      - '.github/workflows/powershell-qa-lean.yml'
    types: [opened, synchronize, reopened]
  
  workflow_dispatch:
    inputs:
      full_scan:
        description: 'Run full scan (ignores path filters)'
        required: false
        default: false
        type: boolean
      
      auto_fix:
        description: 'Apply automatic fixes'
        required: false
        default: false
        type: boolean

env:
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1

jobs:
  # 💰 SINGLE JOB: Combines health check + analysis for cost efficiency
  powershell-qa:
    name: 🔍 PowerShell Quality Check
    runs-on: ubuntu-latest  # 💰 Cheapest runner
    timeout-minutes: 8      # 💰 Short timeout to prevent runaway costs
    
    # 💰 Skip if no PowerShell files changed (unless manual full scan)
    if: |
      github.event.inputs.full_scan == 'true' || 
      contains(join(github.event.commits.*.modified, ' '), '.ps1') ||
      contains(join(github.event.commits.*.modified, ' '), '.psm1') ||
      contains(join(github.event.commits.*.modified, ' '), '.psd1') ||
      contains(join(github.event.commits.*.added, ' '), '.ps1') ||
      contains(join(github.event.commits.*.added, ' '), '.psm1') ||
      contains(join(github.event.commits.*.added, ' '), '.psd1') ||
      github.event_name == 'pull_request' ||
      github.event_name == 'workflow_dispatch'
    
    outputs:
      issues-found: ${{ steps.analysis.outputs.issues }}
      files-scanned: ${{ steps.analysis.outputs.files }}
      needs-attention: ${{ steps.analysis.outputs.needs-attention }}
    
    steps:
      - name: 📥 Checkout (Shallow)
        uses: actions/checkout@v5
        with:
          fetch-depth: 1  # 💰 Shallow clone for speed
      
      - name: 🔧 Setup PowerShell (Cached)
        shell: pwsh
        run: |
          # 💰 Use system PowerShell where possible, only install what's needed
          if (-not (Get-Module -ListAvailable -Name PSScriptAnalyzer)) {
            Write-Output "📦 Installing PSScriptAnalyzer..."
            Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser -Repository PSGallery
          } else {
            Write-Output "✅ PSScriptAnalyzer already available"
          }

      - name: 🏥 Quick Health Check
        shell: pwsh
        run: |
          Write-Output "🏥 Quick health check..."
          
          # Check if QA system exists
          if (-not (Test-Path "psqa.ps1")) {
            Write-Output "❌ QA system not found - using direct analysis"
            exit 0
          }
          
          # Quick validation
          try {
            & "./psqa.ps1" -Mode validate -Path "qa" -Timeout 30
            Write-Output "✅ QA system healthy"
          } catch {
            Write-Output "⚠️ QA system issue, falling back to direct analysis: $_"
          }

      - name: 🎯 Smart PowerShell Analysis
        id: analysis
        shell: pwsh
        run: |
          Write-Output "🎯 Running cost-optimized PowerShell analysis..."
          
          # 💰 Find only changed PowerShell files if not full scan
          if ("${{ github.event.inputs.full_scan }}" -eq "true") {
            Write-Output "🔍 Full scan requested"
            $filesToScan = Get-ChildItem -Recurse -Include "*.ps1","*.psm1","*.psd1" | 
              Where-Object { $_.FullName -notlike "*/.venv/*" -and $_.FullName -notlike "*/node_modules/*" }
          } else {
            Write-Output "🎯 Scanning changed files only"
            
            # Get changed files from git (cost-optimized approach)
            $changedFiles = @()
            try {
              $gitFiles = git diff --name-only HEAD~1 HEAD 2>/dev/null | Where-Object { $_ -match '\.(ps1|psm1|psd1)$' }
              foreach ($file in $gitFiles) {
                if (Test-Path $file) {
                  $changedFiles += Get-Item $file
                }
              }
            } catch {
              # Fallback: scan all if git fails
              Write-Output "⚠️ Git diff failed, scanning all files"
              $changedFiles = Get-ChildItem -Recurse -Include "*.ps1","*.psm1","*.psd1" | 
                Where-Object { $_.FullName -notlike "*/.venv/*" }
            }
            
            $filesToScan = $changedFiles
          }
          
          $fileCount = ($filesToScan | Measure-Object).Count
          Write-Output "📁 Found $fileCount PowerShell files to scan"
          
          if ($fileCount -eq 0) {
            Write-Output "✅ No PowerShell files to scan"
            Write-Output "issues=0" >> $env:GITHUB_OUTPUT
            Write-Output "files=0" >> $env:GITHUB_OUTPUT
            Write-Output "needs-attention=false" >> $env:GITHUB_OUTPUT
            exit 0
          }
          
          # 💰 Use QA system if available, otherwise direct analysis
          $issues = @()
          $useQASystem = Test-Path "psqa.ps1"
          
          if ($useQASystem) {
            try {
              Write-Output "🔧 Using QA system for analysis..."
              $result = & "./psqa.ps1" -Mode analyze -Path ($filesToScan[0].Directory.FullName) 2>&1
              Write-Output $result
              
              # Count issues from QA system output
              $issueLines = $result | Where-Object { $_ -match "Issues found|violations|errors" }
              $issueCount = 0
              if ($issueLines) {
                $numbers = $issueLines | ForEach-Object { [regex]::Matches($_, '\d+').Value }
                $issueCount = ($numbers | Measure-Object -Sum).Sum
              }
            } catch {
              Write-Output "⚠️ QA system failed: $_"
              $useQASystem = $false
            }
          }
          
          if (-not $useQASystem) {
            Write-Output "🔍 Using direct PSScriptAnalyzer..."
            $issues = $filesToScan | ForEach-Object {
              Write-Output "  Analyzing: $($_.Name)"
              if (Test-Path "qa/config/PSScriptAnalyzerSettings.psd1") {
                Invoke-ScriptAnalyzer -Path $_.FullName -Settings "qa/config/PSScriptAnalyzerSettings.psd1" -ErrorAction SilentlyContinue
              } else {
                Invoke-ScriptAnalyzer -Path $_.FullName -ErrorAction SilentlyContinue
              }
            }
            $issueCount = ($issues | Measure-Object).Count
          }
          
          Write-Output "📊 Analysis Results:"
          Write-Output "  Files Scanned: $fileCount"
          Write-Output "  Issues Found: $issueCount"
          
          # 💰 Only create detailed reports if issues found
          if ($issueCount -gt 0) {
            Write-Output "📋 Issue Summary:"
            if ($issues) {
              $issues | Group-Object RuleName | Sort-Object Count -Descending | Select-Object -First 5 | ForEach-Object {
                Write-Output "  • $($_.Name): $($_.Count) occurrences"
              }
            }
          }
          
          # Set outputs
          Write-Output "issues=$issueCount" >> $env:GITHUB_OUTPUT
          Write-Output "files=$fileCount" >> $env:GITHUB_OUTPUT
          Write-Output "needs-attention=$(if ($issueCount -gt 0) { 'true' } else { 'false' })" >> $env:GITHUB_OUTPUT

      - name: 🛠️ Auto-Fix (Optional)
        if: |
          steps.analysis.outputs.needs-attention == 'true' && 
          github.event.inputs.auto_fix == 'true' &&
          github.event_name == 'workflow_dispatch'
        shell: pwsh
        run: |
          Write-Output "🛠️ Applying automatic fixes..."
          
          if (Test-Path "psqa.ps1") {
            try {
              & "./psqa.ps1" -Mode fix -Path "."
              Write-Output "✅ Auto-fixes applied successfully"
            } catch {
              Write-Output "❌ Auto-fix failed: $_"
            }
          } else {
            Write-Output "⚠️ No QA system available for auto-fixing"
          }

      - name: 📊 Cost Summary
        if: always()
        run: |
          echo "## 💸 Cost-Optimized PowerShell QA Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📊 Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Files Scanned**: ${{ steps.analysis.outputs.files }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Issues Found**: ${{ steps.analysis.outputs.issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner**: ubuntu-latest (cheapest)" >> $GITHUB_STEP_SUMMARY
          echo "- **Duration**: ~$(date -u +'%M:%S') minutes" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.analysis.outputs.needs-attention }}" == "true" ]]; then
            echo "### ⚠️ Action Required" >> $GITHUB_STEP_SUMMARY
            echo "PowerShell quality issues detected. Consider running:" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo './psqa.ps1 -Mode fix -Path .' >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "### ✅ All Clear" >> $GITHUB_STEP_SUMMARY
            echo "No PowerShell quality issues detected! 🎉" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 💰 Cost Optimizations Applied" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Path filters (only runs when PS files change)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Ubuntu runner (cheapest available)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Shallow git clone" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Smart file detection" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Short timeout (8 minutes max)" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ Minimal artifact storage" >> $GITHUB_STEP_SUMMARY

  # 💰 OPTIONAL: Manual fix job (only if requested)
  create-fix-pr:
    name: 🔧 Create Auto-Fix PR
    runs-on: ubuntu-latest
    needs: powershell-qa
    if: |
      needs.powershell-qa.outputs.needs-attention == 'true' &&
      github.event.inputs.auto_fix == 'true' &&
      github.event_name == 'workflow_dispatch'
    timeout-minutes: 5
    
    steps:
      - name: 📥 Checkout
        uses: actions/checkout@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: 🔧 Setup PowerShell
        shell: pwsh
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser

      - name: 🛠️ Apply Fixes
        shell: pwsh
        run: |
          if (Test-Path "psqa.ps1") {
            & "./psqa.ps1" -Mode fix -Path "."
          }

      - name: 📤 Create PR
        uses: peter-evans/create-pull-request@v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "🤖 PowerShell: Auto-fix quality issues"
          title: "🤖 Auto-fix PowerShell Quality Issues"
          body: |
            ## 🤖 Automated PowerShell Fixes
            
            This PR contains automatic fixes for PowerShell quality issues.
            
            **Files affected**: ${{ needs.powershell-qa.outputs.files }}
            **Issues fixed**: ${{ needs.powershell-qa.outputs.issues }}
            
            All fixes are safe and maintain existing functionality.
          branch: auto-fix/powershell-${{ github.run_number }}
          labels: automated, powershell, quality
          delete-branch: true