name: PowerShell Quality Assurance (macOS Native)

on:
  push:
    branches: [ main, develop ]
    paths:
      - '**/*.ps1'
      - '**/*.psm1'
      - '**/*.psd1'
      - 'tools/powershell-qa/**'
      - '.github/workflows/powershell-qa.yml'
  
  pull_request:
    branches: [ main, develop ]
    paths:
      - '**/*.ps1'
      - '**/*.psm1' 
      - '**/*.psd1'
      - 'tools/powershell-qa/**'
      - '.github/workflows/powershell-qa.yml'
  
  workflow_dispatch:
    inputs:
      severity:
        description: 'Analysis severity level'
        required: false
        default: 'Warning'
        type: choice
        options:
          - Error
          - Warning
          - Information
      
      self_heal:
        description: 'Enable self-healing capabilities'
        required: false
        default: false
        type: boolean

env:
  # PowerShell preferences for CI/CD
  POWERSHELL_TELEMETRY_OPTOUT: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  
  # QA Engine configuration
  PSQA_LOG_LEVEL: Info
  PSQA_GITHUB_ACTIONS: true
  
  # macOS specific environment
  HOMEBREW_NO_AUTO_UPDATE: 1
  TERM: xterm-256color

jobs:
  powershell-quality-assurance:
    name: PowerShell QA (macOS-Native)
    runs-on: macos-latest
    
    permissions:
      contents: read
      issues: write
      pull-requests: write
      checks: write
      security-events: write
    
    steps:
      - name: üõéÔ∏è Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for comprehensive analysis
      
      - name: üçé Setup macOS development environment
        run: |
          # Ensure Homebrew is available
          if ! command -v brew &> /dev/null; then
            echo "::error::Homebrew not found. macOS runner should have Homebrew pre-installed."
            exit 1
          fi
          
          # Update PATH for GitHub Actions
          echo "/opt/homebrew/bin:/usr/local/bin" >> $GITHUB_PATH
          
          # System information
          echo "::group::macOS System Information"
          sw_vers
          uname -a
          echo "::endgroup::"
          
          # Create logs directory
          mkdir -p logs
          
          echo "‚úÖ macOS environment ready"
      
      - name: üîß Install PowerShell 7
        run: |
          echo "::group::PowerShell Installation"
          
          # Check if PowerShell is already installed
          if command -v pwsh &> /dev/null; then
            echo "PowerShell already installed: $(pwsh --version)"
          else
            echo "Installing PowerShell via Homebrew..."
            brew install --cask powershell
          fi
          
          # Verify installation
          pwsh --version
          pwsh -Command '$PSVersionTable | ConvertTo-Json'
          
          echo "::endgroup::"
      
      - name: üì¶ Install PowerShell modules
        run: |
          echo "::group::PowerShell Module Installation"
          
          pwsh -Command "
            Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
            
            # Install required modules
            \$modules = @('PSScriptAnalyzer', 'Pester')
            foreach (\$module in \$modules) {
              Write-Host \"Installing module: \$module\"
              Install-Module -Name \$module -Scope CurrentUser -Force -SkipPublisherCheck
              \$installed = Get-Module -Name \$module -ListAvailable | Select-Object -First 1
              Write-Host \"‚úÖ \$module v\$(\$installed.Version) installed\"
            }
            
            # Verify installations
            Write-Host '::group::Module Verification'
            Get-Module -ListAvailable | Where-Object { \$_.Name -in @('PSScriptAnalyzer', 'Pester') } | 
              Format-Table Name, Version, ModuleBase
            Write-Host '::endgroup::'
          "
          
          echo "::endgroup::"
      
      - name: üîç Discover PowerShell files
        id: discovery
        run: |
          echo "::group::File Discovery"
          
          # Find PowerShell files
          PS_FILES=$(find . -name "*.ps1" -o -name "*.psm1" -o -name "*.psd1" | \
            grep -v ".git/" | \
            grep -v "node_modules/" | \
            grep -v ".backup/" | \
            head -100)  # Limit to prevent overwhelming output
          
          PS_COUNT=$(echo "$PS_FILES" | grep -c . || echo "0")
          
          echo "files_found=$PS_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$PS_COUNT" -eq "0" ]; then
            echo "::warning::No PowerShell files found to analyze"
            echo "files_to_analyze=" >> $GITHUB_OUTPUT
          else
            echo "::notice::Found $PS_COUNT PowerShell files to analyze"
            echo "$PS_FILES" | while read file; do
              echo "  üìÑ $file"
            done
            
            # Store files for next step (truncate if too long)
            echo "$PS_FILES" | head -50 > ps_files_list.txt
          fi
          
          echo "::endgroup::"
      
      - name: üß™ Run PowerShell Quality Assurance Engine
        id: psqa
        if: steps.discovery.outputs.files_found != '0'
        run: |
          echo "::group::PowerShell Quality Analysis"
          
          # Set parameters based on inputs
          SEVERITY="${{ github.event.inputs.severity || 'Warning' }}"
          SELF_HEAL="${{ github.event.inputs.self_heal || 'false' }}"
          
          echo "Analysis Configuration:"
          echo "  Severity: $SEVERITY"
          echo "  Self-Heal: $SELF_HEAL"
          echo "  GitHub Actions: true"
          
          # Ensure QA engine is executable
          chmod +x tools/powershell-qa/src/Invoke-PSQAEngine-macOS.ps1
          
          # Run the QA engine
          pwsh -Command "
            \$ErrorActionPreference = 'Stop'
            
            # Set GitHub Actions environment
            \$env:GITHUB_ACTIONS = 'true'
            \$env:GITHUB_STEP_SUMMARY = '${{ github.step_summary || 'step_summary.md' }}'
            \$env:GITHUB_OUTPUT = '${{ github.output || 'github_output.txt' }}'
            
            # Build parameters
            \$params = @{
              Path = '.'
              Mode = 'validate'
              Severity = '$SEVERITY'
              OutputFormat = 'GitHub'
              GitHubActions = \$true
              NoColor = \$true
            }
            
            if ('$SELF_HEAL' -eq 'true') {
              \$params['SelfHeal'] = \$true
            }
            
            # Execute QA engine
            Write-Host 'üöÄ Starting PowerShell QA Engine...'
            try {
              & './tools/powershell-qa/src/Invoke-PSQAEngine-macOS.ps1' @params
              \$exitCode = \$LASTEXITCODE
              
              Write-Host \"QA engine completed with exit code: \$exitCode\"
              exit \$exitCode
            } catch {
              Write-Host \"::error::QA engine execution failed: \$(\$_.Exception.Message)\"
              Write-Host \"::error::Stack trace: \$(\$_.ScriptStackTrace)\"
              exit 1
            }
          "
          
          echo "::endgroup::"
      
      - name: üìä Upload QA results
        if: always() && steps.discovery.outputs.files_found != '0'
        uses: actions/upload-artifact@v4
        with:
          name: powershell-qa-results-${{ github.run_number }}
          path: |
            logs/
            step_summary.md
            github_output.txt
          retention-days: 30
      
      - name: üí¨ Comment on PR
        if: always() && github.event_name == 'pull_request' && steps.discovery.outputs.files_found != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            try {
              // Read the step summary if it exists
              let qaResults = '';
              if (fs.existsSync('step_summary.md')) {
                qaResults = fs.readFileSync('step_summary.md', 'utf8');
              }
              
              // Read GitHub outputs if available
              let outputs = {};
              if (fs.existsSync('github_output.txt')) {
                const outputLines = fs.readFileSync('github_output.txt', 'utf8').split('\n');
                for (const line of outputLines) {
                  const [key, value] = line.split('=', 2);
                  if (key && value) outputs[key] = value;
                }
              }
              
              const comment = `## üçé PowerShell Quality Assurance Results
              
              **Workflow**: ${context.workflow}  
              **Run ID**: ${context.runId}  
              **Commit**: ${context.sha.substring(0, 7)}
              
              ${qaResults || 'No detailed results available'}
              
              ${outputs.total_issues === '0' ? '‚úÖ **All checks passed!**' : 
                `‚ö†Ô∏è **Found ${outputs.total_issues || 'unknown'} issues** - please review before merging`}
              
              ---
              *Generated by PowerShell QA Engine v3.0.0-macOS*`;
              
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
              
              console.log('‚úÖ PR comment posted successfully');
            } catch (error) {
              console.log(`‚ùå Failed to post PR comment: ${error.message}`);
            }
      
      - name: üîí Security scan (Bandit equivalent for PS1)
        if: steps.discovery.outputs.files_found != '0'
        run: |
          echo "::group::Security Analysis"
          
          pwsh -Command "
            # Basic security pattern scanning for PowerShell
            \$securityPatterns = @(
              @{ Pattern = 'Invoke-Expression|iex'; Risk = 'High'; Description = 'Code injection risk' }
              @{ Pattern = 'DownloadString|DownloadFile'; Risk = 'Medium'; Description = 'Download execution risk' }
              @{ Pattern = 'ConvertTo-SecureString.*-AsPlainText'; Risk = 'High'; Description = 'Plain text secrets' }
              @{ Pattern = 'Start-Process.*-WindowStyle Hidden'; Risk = 'Medium'; Description = 'Hidden process execution' }
              @{ Pattern = 'New-Object.*Net\.WebClient'; Risk = 'Medium'; Description = 'Web client usage' }
              @{ Pattern = 'Add-Type.*-TypeDefinition'; Risk = 'Medium'; Description = 'Dynamic code compilation' }
            )
            
            \$findings = @()
            Get-ChildItem -Recurse -Filter '*.ps1' -ErrorAction SilentlyContinue | ForEach-Object {
              \$content = Get-Content \$_.FullName -Raw -ErrorAction SilentlyContinue
              if (\$content) {
                foreach (\$pattern in \$securityPatterns) {
                  if (\$content -match \$pattern.Pattern) {
                    \$findings += @{
                      File = \$_.Name
                      Risk = \$pattern.Risk
                      Description = \$pattern.Description
                      Pattern = \$pattern.Pattern
                    }
                  }
                }
              }
            }
            
            if (\$findings.Count -gt 0) {
              Write-Host '‚ö†Ô∏è Security findings detected:'
              \$findings | ForEach-Object {
                Write-Host \"::warning file=\$(\$_.File)::Security risk (\$(\$_.Risk)): \$(\$_.Description)\"
              }
            } else {
              Write-Host '‚úÖ No security patterns detected'
            }
          "
          
          echo "::endgroup::"
      
      - name: üè• Health check summary
        if: always()
        run: |
          echo "::group::Workflow Health Summary"
          
          echo "## üè• Workflow Health Check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status | Version/Info |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|---------------|" >> $GITHUB_STEP_SUMMARY
          echo "| macOS | ‚úÖ $(sw_vers -productVersion) | $(uname -m) |" >> $GITHUB_STEP_SUMMARY
          echo "| PowerShell | ‚úÖ $(pwsh --version 2>/dev/null || echo 'Not Available') | Core |" >> $GITHUB_STEP_SUMMARY
          echo "| Homebrew | $(brew --version &>/dev/null && echo '‚úÖ' || echo '‚ùå') | $(brew --version 2>/dev/null | head -1 || echo 'N/A') |" >> $GITHUB_STEP_SUMMARY
          echo "| QA Engine | ${{ steps.psqa.outcome == 'success' && '‚úÖ' || '‚ùå' }} | v3.0.0-macOS |" >> $GITHUB_STEP_SUMMARY
          
          echo "::endgroup::"
      
      - name: üéØ Set final status
        if: always()
        run: |
          if [[ "${{ steps.psqa.outcome }}" == "success" ]]; then
            echo "::notice::‚úÖ PowerShell quality assurance passed"
          elif [[ "${{ steps.discovery.outputs.files_found }}" == "0" ]]; then
            echo "::notice::‚ÑπÔ∏è No PowerShell files found - skipping QA"
          else
            echo "::error::‚ùå PowerShell quality assurance failed"
            exit 1
          fi